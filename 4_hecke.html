<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4&nbsp; Hecke Theory – Modular Forms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./5_eisenstein.html" rel="next">
<link href="./3_complextori.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./4_hecke.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hecke Theory</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Modular Forms</a> 
        <div class="sidebar-tools-main">
    <a href="https://www.github.com/mmasdeu/modforms" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Modular-Forms.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1_modformslevelone.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Modular forms of level one</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2_modformscongruence.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Modular forms for congruence subgroups</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3_complextori.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Moduli interpretation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./4_hecke.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hecke Theory</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./5_eisenstein.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Eisenstein series</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./6_lfunctions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">L-functions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./7_modsym.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Modular symbols</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./bibliography.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bibliography</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#double-coset-operators" id="toc-double-coset-operators" class="nav-link active" data-scroll-target="#double-coset-operators"><span class="header-section-number">4.1</span> Double coset operators</a>
  <ul class="collapse">
  <li><a href="#first-examples" id="toc-first-examples" class="nav-link" data-scroll-target="#first-examples"><span class="header-section-number">4.1.1</span> First examples</a></li>
  </ul></li>
  <li><a href="#hecke-operators-for-gamma_1n" id="toc-hecke-operators-for-gamma_1n" class="nav-link" data-scroll-target="#hecke-operators-for-gamma_1n"><span class="header-section-number">4.2</span> Hecke operators for <span class="math inline">\(\Gamma_1(N)\)</span></a>
  <ul class="collapse">
  <li><a href="#the-t_p-operators" id="toc-the-t_p-operators" class="nav-link" data-scroll-target="#the-t_p-operators"><span class="header-section-number">4.2.1</span> The <span class="math inline">\(T_p\)</span> operators</a></li>
  <li><a href="#the-diamond-langle-d-rangle-operators" id="toc-the-diamond-langle-d-rangle-operators" class="nav-link" data-scroll-target="#the-diamond-langle-d-rangle-operators"><span class="header-section-number">4.2.2</span> The diamond <span class="math inline">\(\langle d \rangle\)</span> operators</a></li>
  <li><a href="#hecke-operators-on-q-expansions" id="toc-hecke-operators-on-q-expansions" class="nav-link" data-scroll-target="#hecke-operators-on-q-expansions"><span class="header-section-number">4.2.3</span> Hecke operators on <span class="math inline">\(q\)</span>-expansions</a></li>
  </ul></li>
  <li><a href="#the-hecke-algebra" id="toc-the-hecke-algebra" class="nav-link" data-scroll-target="#the-hecke-algebra"><span class="header-section-number">4.3</span> The Hecke algebra</a></li>
  <li><a href="#petersson-inner-product" id="toc-petersson-inner-product" class="nav-link" data-scroll-target="#petersson-inner-product"><span class="header-section-number">4.4</span> Petersson inner product</a>
  <ul class="collapse">
  <li><a href="#surface-integrals" id="toc-surface-integrals" class="nav-link" data-scroll-target="#surface-integrals"><span class="header-section-number">4.4.1</span> Surface integrals</a></li>
  <li><a href="#integral-over-xgamma" id="toc-integral-over-xgamma" class="nav-link" data-scroll-target="#integral-over-xgamma"><span class="header-section-number">4.4.2</span> Integral over <span class="math inline">\(X(\Gamma)\)</span></a></li>
  <li><a href="#adjoint-operators" id="toc-adjoint-operators" class="nav-link" data-scroll-target="#adjoint-operators"><span class="header-section-number">4.4.3</span> Adjoint operators</a></li>
  </ul></li>
  <li><a href="#atkin-lehner-li-theory" id="toc-atkin-lehner-li-theory" class="nav-link" data-scroll-target="#atkin-lehner-li-theory"><span class="header-section-number">4.5</span> Atkin-Lehner-Li theory</a>
  <ul class="collapse">
  <li><a href="#examples" id="toc-examples" class="nav-link" data-scroll-target="#examples"><span class="header-section-number">4.5.1</span> Examples</a></li>
  <li><a href="#sec:newforms" id="toc-sec:newforms" class="nav-link" data-scroll-target="#sec\:newforms"><span class="header-section-number">4.5.2</span> New and old forms</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://www.github.com/mmasdeu/modforms/edit/main/4_hecke.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://www.github.com/mmasdeu/modforms/issues" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://www.github.com/mmasdeu/modforms/blob/main/4_hecke.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-hecke" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hecke Theory</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="hidden">

</div>
<section id="double-coset-operators" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="double-coset-operators"><span class="header-section-number">4.1</span> Double coset operators</h2>
<p>Let <span class="math inline">\(\Gamma_1\)</span> and <span class="math inline">\(\Gamma_2\)</span> be two congruence subgroups, and let <span class="math inline">\(\alpha\in\operatorname{GL}_2^+({\mathbb{Q}})\)</span>.</p>
<div id="def-" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4.1</strong></span> The <span class="math inline">\(\Gamma_1\alpha\Gamma_2\)</span> is the set <span class="math display">\[\Gamma_1\alpha\Gamma_2=\{\gamma_1\alpha\gamma_2 ~|~ \gamma_1\in\Gamma_1,\gamma_2\in\Gamma_2\}.\]</span></p>
</div>
<p>Multiplication gives a left action of <span class="math inline">\(\Gamma_1\)</span> on <span class="math inline">\(\Gamma_1\alpha\Gamma_2\)</span> and another right action of <span class="math inline">\(\Gamma_2\)</span>. Consider a decomposition of this double coset into (disjoint) orbits: <span class="math display">\[\Gamma_1\alpha\Gamma_2=\cup \Gamma_1 \beta_j.\]</span></p>
<div id="lem-" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 4.1</strong></span> &nbsp;</p>
<ol type="1">
<li><p>If <span class="math inline">\(\Gamma\)</span> is a congruence subgroup and <span class="math inline">\(\alpha\in\operatorname{GL}_2^+({\mathbb{Q}})\)</span>, then <span class="math inline">\(\alpha^{-1}\Gamma\alpha\cap {\operatorname{SL}}_2({\mathbb{Z}})\)</span> is also congruence subgroup.</p></li>
<li><p>Any two congruence subgroups <span class="math inline">\(\Gamma_1\)</span>, <span class="math inline">\(\Gamma_2\)</span> are . That is, <span class="math display">\[[\Gamma_1\colon \Gamma_1\cap\Gamma_2]&lt;\infty\quad\text{ and }\quad [\Gamma_2\colon \Gamma_1\cap\Gamma_2]&lt;\infty.\]</span></p></li>
</ol>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">\(N\)</span> be a positive integer such that <span class="math inline">\(\Gamma(N)\subseteq \Gamma\)</span>, <span class="math inline">\(N\alpha\in M_2({\mathbb{Z}})\)</span> and <span class="math inline">\(N\alpha^{-1}\in M_2({\mathbb{Z}})\)</span>. Set <span class="math inline">\(M=N^3\)</span>. Then one can check that <span class="math inline">\(\alpha\Gamma(M)\alpha^{-1} \subseteq \Gamma(N)\)</span>, which implies that <span class="math inline">\(\Gamma(M)\subseteq \alpha^{-1}\Gamma\alpha\)</span>. Since <span class="math inline">\(\Gamma(M)\)</span> is also contained in <span class="math inline">\({\operatorname{SL}}_2({\mathbb{Z}})\)</span>, we are done with the first statement.</p>
<p>For the second assertion, just note that there is some <span class="math inline">\(M\)</span> such that <span class="math inline">\(\Gamma(M)\subseteq \Gamma_1\cap\Gamma_2\)</span>. Therefore the indices to compute are bounded above by <span class="math inline">\([{\operatorname{SL}}_2({\mathbb{Z}})\colon\Gamma(M)]\)</span>, which is finite.</p>
</div>
<div id="prp-" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4.1</strong></span> Let <span class="math inline">\(\Gamma_1\)</span> and <span class="math inline">\(\Gamma_2\)</span> be two congruence subgroups, and let <span class="math inline">\(\alpha\in\operatorname{GL}_2^+({\mathbb{Q}})\)</span>. Set <span class="math inline">\(\Gamma_3\)</span> to be the congruence subgroup: <span class="math display">\[\Gamma_3 = (\alpha^{-1}\Gamma_1\alpha)\cap \Gamma_2.\]</span> The map <span class="math inline">\(\gamma_2\mapsto \Gamma_1\alpha\gamma_2\)</span> induces a bijection <span class="math display">\[\Gamma_3\backslash \Gamma_2 \cong \Gamma_1\backslash \Gamma_1\alpha\Gamma_2.\]</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Consider the map <span class="math display">\[\Gamma_2\longrightarrow\Gamma_1\backslash (\Gamma_1\alpha\Gamma_2),\quad \gamma_2\mapsto \Gamma_1\alpha\gamma_2.\]</span> It is clearly surjective. Moreover, two elements <span class="math inline">\(\gamma_2\)</span> and <span class="math inline">\(\gamma_2'\)</span> get mapped to the same orbit if and only if: <span class="math display">\[\Gamma_1\alpha\gamma_2=\Gamma_1\alpha\gamma_2'\iff \gamma_2'\gamma_2^{-1}\in\alpha^{-1}\Gamma_1\alpha,\]</span> and the latter happens if and only if <span class="math inline">\(\gamma_2\)</span> and <span class="math inline">\(\gamma_2'\)</span> are in the same coset for <span class="math inline">\((\alpha^{-1}\Gamma_1\alpha) \cap\Gamma_2=\Gamma_3\)</span>.</p>
</div>
<div id="cor-" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 4.1</strong></span> Let <span class="math inline">\(\Gamma_2=\cup \Gamma_3\gamma_j\)</span> be a coset decomposition of <span class="math inline">\(\Gamma_3\backslash\Gamma_2\)</span>. Then <span class="math display">\[\Gamma_1\alpha\Gamma_2=\cup \Gamma_1\alpha\gamma_j\]</span> is an orbit decomposition. In particular, the number of orbits of <span class="math inline">\(\Gamma_1\alpha\Gamma_2\)</span> under the action of <span class="math inline">\(\Gamma_1\)</span> is finite.</p>
</div>
<p>Let <span class="math inline">\(f\in M_k(\Gamma_1)\)</span> be a modular form of weight <span class="math inline">\(k\)</span> for a congruence subgroup <span class="math inline">\(\Gamma_1\)</span>. Let <span class="math inline">\(\Gamma_1\alpha\Gamma_2\)</span> be a double coset, where <span class="math inline">\(\Gamma_2\)</span> is a congruence subgroup and <span class="math inline">\(\alpha\in\operatorname{GL}_2^+({\mathbb{Q}})\)</span>. The on <span class="math inline">\(f\)</span> is defined as: <span class="math display">\[f|_k (\Gamma_1\alpha\Gamma_2) = \sum f|_k \beta_j,\]</span> if <span class="math inline">\(\Gamma_1\alpha\Gamma_2=\cup \Gamma_1\beta_j\)</span> is any orbit decomposition.</p>
<div id="rmk-">
<p>The action is well defined, independent of the choice of the <span class="math inline">\(\beta_j\)</span>. This is so because <span class="math inline">\(f\)</span> is <span class="math inline">\(k\)</span>-invariant under <span class="math inline">\(\Gamma_1\)</span>.</p>
</div>
<p>The next goal is to show that the double coset operator maps <span class="math inline">\(M_k(\Gamma_1)\)</span> to <span class="math inline">\(M_k(\Gamma_2)\)</span> and preserves cusps forms. We will need a technical lemma to treat the cusp conditions.</p>
<div id="lem-cusp-conditions" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 4.2</strong></span> Suppose that for all <span class="math inline">\(\gamma\in{\operatorname{SL}}_2({\mathbb{Z}})\)</span> the function <span class="math inline">\(f|_k\gamma\)</span> has an expansion of the form <span class="math display">\[\sum_{n\geq n_0} a(n)q_N^n,\]</span> with <span class="math inline">\(n_0\)</span> and <span class="math inline">\(a(n)\)</span> depending on <span class="math inline">\(\gamma\)</span>. Let <span class="math inline">\(\alpha\in\operatorname{GL}_2^+({\mathbb{Q}})\)</span>. Then for all <span class="math inline">\(\gamma\in{\operatorname{SL}}_2({\mathbb{Z}})\)</span> the function <span class="math inline">\(f|_k(\alpha\gamma)\)</span> has the expansion <span class="math display">\[\sum_{n\geq an_0} b(n)q_{Nd}^n,\]</span> where <span class="math inline">\(a\)</span> and <span class="math inline">\(d\)</span> are positive integers depending only on <span class="math inline">\(\alpha\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>First, note that, for <span class="math inline">\(a&gt;0\)</span>, <span class="math display">\[f|_k\left(\begin{matrix}a&amp;0\\0&amp;a\end{matrix}\right) = a^{2(k-1)}a^{-k}f = a^{k-2}f.\]</span> So without loss of generality we may assume that <span class="math inline">\(\alpha\in M_2({\mathbb{Z}})\)</span>. Let <span class="math inline">\(\gamma_0\in{\operatorname{SL}}_2({\mathbb{Z}})\)</span> be such that <span class="math inline">\(\gamma_0^{-1}\alpha=\left(\begin{smallmatrix}a&amp;b\\0&amp;d\end{smallmatrix}\right)\)</span> (upper-triangular), with <span class="math inline">\(a\)</span> and <span class="math inline">\(d\)</span> being positive integers. Then: <span class="math display">\[\begin{align*}
f|_k\alpha &amp;= (f|_k\gamma_0)|_k\left(\begin{matrix}a&amp;b\\0&amp;d\end{matrix}\right) = \left(\sum_{n\geq n_0}a(n)e^{\frac{2\pi i n z}{N}}\right)|_k\left(\begin{matrix}a&amp;b\\0&amp;d\end{matrix}\right)\\
&amp;=(\cdots)\sum_{n\geq n_0} a(n)e^{\frac{2\pi i n(az+b)}{dN}} = (\cdots) q_{Nd}^{an_0}+\cdots
\end{align*}\]</span> This concludes the proof.</p>
</div>
<div id="prp-double-coset-operators" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4.2</strong></span> Let <span class="math inline">\(\Gamma_1\)</span> and <span class="math inline">\(\Gamma_2\)</span> be two congruence subgroups, and let <span class="math inline">\(\alpha\in\operatorname{GL}_2^+({\mathbb{Q}})\)</span>. The rule <span class="math inline">\(f\mapsto f|_k\Gamma_1\alpha\Gamma_2\)</span> induces a map <span class="math inline">\(M_k(\Gamma_1)\longrightarrow M_k(\Gamma_2)\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Write <span class="math inline">\(\Gamma_3=(\alpha^{-1}\Gamma_1\alpha)\cap \Gamma_2\)</span>, and consider a coset decomposition <span class="math inline">\(\Gamma_2= \cup \Gamma_3\gamma_j\)</span>. One can take as set of representatives <span class="math inline">\(\beta_j=\alpha\gamma_j\)</span>. If <span class="math inline">\(\gamma_2\in\Gamma_2\)</span>, then <span class="math inline">\(\{\gamma_j\gamma_2\}_j\)</span> is a complete set of representatives for <span class="math inline">\(\Gamma_3\backslash \Gamma_2\)</span>, and hence <span class="math inline">\(\{\alpha\gamma_j\gamma_2\}_j\)</span> is a complete set of representatives for <span class="math inline">\(\Gamma_1\backslash\Gamma_1\alpha\Gamma_2\)</span>. This implies that <span class="math inline">\(f|_k\Gamma_1\alpha\Gamma_2\)</span> is <span class="math inline">\(k\)</span>-invariant for <span class="math inline">\(\Gamma_2\)</span>.</p>
<p>If <span class="math inline">\(f\)</span> is holomorphic on <span class="math inline">\({\mathbb{H}}\)</span>, then <span class="math inline">\(f|_k\beta_j\)</span> is holomorphic on <span class="math inline">\({\mathbb{H}}\)</span> for any <span class="math inline">\(\beta_j\in\operatorname{GL}_2^+({\mathbb{Q}})\)</span>, so it only remains to check the cusp conditions. But <a href="#lem-cusp-conditions" class="quarto-xref">Lemma&nbsp;<span>4.2</span></a> precisely ensures that these are preserved.</p>
</div>
<section id="first-examples" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="first-examples"><span class="header-section-number">4.1.1</span> First examples</h3>
<p>Consider the case <span class="math inline">\(\Gamma_2\subseteq \Gamma_1\)</span> and <span class="math inline">\(\alpha=1\)</span>. Then <span class="math inline">\(\Gamma_1\alpha\Gamma_2=\Gamma_1\)</span>, and <span class="math inline">\(\Gamma_1=\Gamma_11\)</span> is an orbit decomposition. Therefore <span class="math inline">\(f|_k\Gamma_1\alpha\Gamma_2 = f|_k1 = f\)</span>. This just says that <span class="math inline">\(M_k(\Gamma_1)\)</span> is a subspace of <span class="math inline">\(M_k(\Gamma_2)\)</span>.</p>
<p>As a more interesting example, given <span class="math inline">\(\alpha\in\operatorname{GL}_2^+({\mathbb{Q}})\)</span> consider the conjugate <span class="math inline">\(\Gamma'=\alpha^{-1}\Gamma\alpha\)</span>. Then <span class="math inline">\(\Gamma\alpha\Gamma'=\Gamma\alpha\)</span> is an orbit decomposition. This implies that acting by <span class="math inline">\(\alpha\)</span> induces a map <span class="math display">\[M_k(\Gamma)\longrightarrow M_k(\alpha^{-1}\Gamma\alpha).\]</span> Since the inverse of this map is given by the action of <span class="math inline">\(\alpha^{-1}\)</span>, we conclude that <span class="math inline">\(M_k(\Gamma)\)</span> and <span class="math inline">\(M_k(\alpha^{-1}\Gamma\alpha)\)</span> are naturally isomorphic.</p>
<p>Finally, consider the case <span class="math inline">\(\Gamma_1\subseteq \Gamma_2\)</span> and <span class="math inline">\(\alpha=1\)</span>. Then <span class="math inline">\(\Gamma_1\alpha\Gamma_2 = \cup \Gamma_1 \beta_j\)</span>, where <span class="math inline">\(\beta_j\)</span> is a set of coset representatives for <span class="math inline">\(\Gamma_1\backslash \Gamma_2\)</span>. The map <span class="math display">\[f\mapsto \sum_{j} f|_k \beta_j\]</span> is to be seen as a <em>trace operator</em> from <span class="math inline">\(M_k(\Gamma_1)\longrightarrow M_k(\Gamma_2)\)</span>. In particular, it maps <span class="math inline">\(f\in M_k(\Gamma_2)\)</span> to <span class="math inline">\([\Gamma_2\colon \Gamma_1]f\)</span> and thus it is surjective.</p>
</section>
</section>
<section id="hecke-operators-for-gamma_1n" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="hecke-operators-for-gamma_1n"><span class="header-section-number">4.2</span> Hecke operators for <span class="math inline">\(\Gamma_1(N)\)</span></h2>
<p>Fix now <span class="math inline">\(\Gamma=\Gamma_1(N)\)</span>. We will describe the Hecke operators for the group <span class="math inline">\(\Gamma\)</span>.</p>
<section id="the-t_p-operators" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="the-t_p-operators"><span class="header-section-number">4.2.1</span> The <span class="math inline">\(T_p\)</span> operators</h3>
<p>Let <span class="math inline">\(p\)</span> be a prime. The at <span class="math inline">\(p\)</span> is defined as: <span class="math display">\[T_p f = f|_k\Gamma_1(N)\left(\begin{matrix}1&amp;0\\0&amp;p\end{matrix}\right)\Gamma_1(N).\]</span> By <a href="#prp-double-coset-operators" class="quarto-xref">Proposition&nbsp;<span>4.2</span></a>, the operator <span class="math inline">\(T_p\)</span> acts on <span class="math inline">\(M_k(\Gamma_1(N))\)</span>.</p>
<p>In order to describe the action of <span class="math inline">\(T_p\)</span> more precisely, we need to understand the double coset <span class="math inline">\(\Gamma_1(N)\left(\begin{smallmatrix}1&amp;0\\0&amp;p\end{smallmatrix}\right)\Gamma_1(N)\)</span>. Note first that if <span class="math inline">\(\gamma\in \Gamma_1(N)\left(\begin{smallmatrix}1&amp;0\\0&amp;p\end{smallmatrix}\right)\Gamma_1(N)\)</span> then:</p>
<ol type="1">
<li><p><span class="math inline">\(\det \gamma = p\)</span>, and</p></li>
<li><p><span class="math inline">\(\gamma\equiv\left(\begin{smallmatrix}1&amp;*\\0&amp;p\end{smallmatrix}\right)\pmod N\)</span>.</p></li>
</ol>
<p>In fact, the converse is true:</p>
<div id="lem-" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 4.3</strong></span> We have that <span class="math display">\[\Gamma_1(N)\left(\begin{matrix}1&amp;0\\0&amp;p\end{matrix}\right)\Gamma_1(N)=\left\{\gamma\in M_2({\mathbb{Z}})~|~\det\gamma = p,\gamma\equiv \left(\begin{smallmatrix}1&amp;*\\0&amp;p\end{smallmatrix}\right)\pmod{N}\right\}.\]</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>To prove the remaining inclusion, let <span class="math inline">\(\gamma\in M_2({\mathbb{Z}})\)</span> have determinant <span class="math inline">\(p\)</span>, and satisfy <span class="math inline">\(\gamma\equiv \left(\begin{smallmatrix}1&amp;*\\0&amp;p\end{smallmatrix}\right)\pmod N\)</span>. Consider <span class="math inline">\(L={\mathbb{Z}}^2\)</span> and <span class="math display">\[L_0=L_0(N)=\{\left(\begin{smallmatrix}x\\y\end{smallmatrix}\right)\in L\colon y\equiv 0\pmod N\}.\]</span> Note that <span class="math inline">\(\gamma L_0\subseteq L_0\)</span>. Since <span class="math inline">\(\det \gamma=p&gt;0\)</span>, we have: <span class="math display">\[[L\colon\gamma L_0]=[L\colon L_0][L_0\colon\gamma L_0] = Np.\]</span> Choose a basis of <span class="math inline">\(L\)</span> adapted to <span class="math inline">\(\gamma L_0\)</span>. That is, a basis <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span> such that <span class="math inline">\(\det(u|v)=1\)</span> and such that <span class="math display">\[\gamma L_0=mu{\mathbb{Z}}\oplus nv{\mathbb{Z}}, \text{ with } 0&lt;m\mid n, mn=Np.\]</span> We will show:</p>
<ol type="1">
<li><p><span class="math inline">\(\gamma L_0=u{\mathbb{Z}}\oplus Np v{\mathbb{Z}}\)</span>.</p></li>
<li><p><span class="math inline">\(L_0 = u{\mathbb{Z}}\oplus Nv{\mathbb{Z}}\)</span>.</p></li>
<li><p><span class="math inline">\(\gamma L = u{\mathbb{Z}}+pv{\mathbb{Z}}\)</span>.</p></li>
</ol>
<p>In fact, since <span class="math inline">\(\gamma\left(\begin{smallmatrix}1\\0\end{smallmatrix}\right)\in \gamma L_0\)</span>, we have that <span class="math inline">\(\left(\begin{smallmatrix}a\\b\end{smallmatrix}\right)\equiv\left(\begin{smallmatrix}0\\0\end{smallmatrix}\right)\pmod m\)</span>. Since <span class="math inline">\(\gcd(a,N)=1\)</span>, this implies that <span class="math inline">\(\gcd(m,N)=1\)</span>. Now, if <span class="math inline">\(p\mid m\)</span>, then <span class="math inline">\(p\mid n\)</span>, and so <span class="math inline">\(p^2\mid mn=Np\)</span>. Therefore <span class="math inline">\(p\mid N\)</span>, which is a contradiction with <span class="math inline">\(\gcd(m,N)=1\)</span>. Therefore <span class="math inline">\(p\nmid m\)</span> and hence <span class="math inline">\(m=1\)</span> and <span class="math inline">\(n=Np\)</span>.</p>
<p>The two other facts follow because <span class="math inline">\(L_0\subset L\)</span> is a subgroup of index <span class="math inline">\(N\)</span>, and <span class="math inline">\(\gamma L\subset L\)</span> is of index <span class="math inline">\(p\)</span> in <span class="math inline">\(L\)</span>. This proves the above three statements.</p>
<p>Next, set <span class="math inline">\(\gamma_1=(u|v)\)</span>, which belongs to <span class="math inline">\(\Gamma_0(N)\)</span> because <span class="math inline">\(u\)</span> belongs to <span class="math inline">\(L_0\)</span>. Set also <span class="math inline">\(\gamma_2=(\gamma_1\left(\begin{smallmatrix}1&amp;0\\0&amp;p\end{smallmatrix}\right))^{-1}\gamma\)</span>, so that <span class="math inline">\(\gamma=\gamma_1\left(\begin{smallmatrix}1&amp;0\\0&amp;p\end{smallmatrix}\right)\gamma_2\)</span>. Note that <span class="math inline">\(\gamma_2\)</span> belongs to <span class="math inline">\({\operatorname{SL}}_2({\mathbb{Q}})\)</span>. It remains to show that <span class="math inline">\(\gamma_1\)</span> and <span class="math inline">\(\gamma_2\)</span> belong to <span class="math inline">\(\Gamma_1(N)\)</span>. This will follow if we can prove:</p>
<ol type="1">
<li><p><span class="math inline">\(\gamma_2\in \Gamma_0(N)\)</span>.</p></li>
<li><p><span class="math inline">\(\Gamma_0(N)\left(\begin{smallmatrix}1&amp;0\\0&amp;p\end{smallmatrix}\right) \Gamma_0(N)=\Gamma_1(N)\left(\begin{smallmatrix}1&amp;0\\0&amp;p\end{smallmatrix}\right)\Gamma_0(N)\)</span>.</p></li>
<li><p>If <span class="math inline">\(\gamma=\gamma_1\left(\begin{smallmatrix}1&amp;0\\0&amp;p\end{smallmatrix}\right)\gamma_2\)</span> with <span class="math inline">\(\gamma_1\in \Gamma_1(N)\)</span> and <span class="math inline">\(\gamma_2\in \Gamma_0(N)\)</span>, then <span class="math inline">\(\gamma_2\)</span> belongs to <span class="math inline">\(\Gamma_1(N)\)</span>.</p></li>
</ol>
<p>Each of these statements can be easily proved, and we ommit these proofs.</p>
</div>
<div id="prp-description-hecke" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4.3</strong></span> Let <span class="math inline">\(f\in M_k(\Gamma_1(N))\)</span>. Then <span class="math inline">\(T_p f\)</span> is given by: <span class="math display">\[T_p f =
\begin{cases}
\sum_{j=0}^{p-1} f|_k \left(\begin{matrix}1&amp;j\\0&amp;p\end{matrix}\right)&amp;p\mid N,\\
\sum_{j=0}^{p-1} f|_k\left(\begin{matrix}1&amp;j\\0&amp;p\end{matrix}\right) +f|_k\left(\begin{matrix}mp&amp;n\\Np&amp;p\end{matrix}\right)&amp;p\nmid N.
\end{cases}\]</span> Here the matrix <span class="math inline">\(\left(\begin{smallmatrix}mp&amp;n\\Np&amp;p\end{smallmatrix}\right)\)</span> is chosen such that <span class="math inline">\(\gamma_\infty=\left(\begin{smallmatrix}mp&amp;n\\N&amp;1\end{smallmatrix}\right)\)</span> belongs to <span class="math inline">\(\Gamma_1(N)\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>We just need to trace the definition of the double coset operator. That is, we need to find an explicit coset decomposition of <span class="math inline">\(\Gamma_3\backslash \Gamma_1(N)\)</span>, where <span class="math display">\[\Gamma_3={\left(\begin{matrix}1&amp;0\\0&amp;p\end{matrix}\right)}^{-1} \Gamma_1(N) \left(\begin{matrix}1&amp;0\\0&amp;p\end{matrix}\right) \cap \Gamma_1(N).\]</span> Define <span class="math inline">\(\Gamma^0(p)\)</span> to be the group of matrices which are lower triangular modulo <span class="math inline">\(p\)</span>. It is easy to see that <span class="math display">\[\Gamma_3 = \Gamma_1(N)\cap \Gamma^0(p).\]</span> Consider the matrices <span class="math inline">\(\gamma_j=\left(\begin{smallmatrix}1&amp;j\\0&amp;1\end{smallmatrix}\right)\)</span>, with <span class="math inline">\(j\)</span> ranging from <span class="math inline">\(0\)</span> to <span class="math inline">\(p-1\)</span> inclusive. These are all distinct modulo <span class="math inline">\(\Gamma_1(N)\cap \Gamma^0(p)\)</span> (check it). Given any matrix <span class="math inline">\(\left(\begin{smallmatrix}a&amp;b\\c&amp;d\end{smallmatrix}\right) \in\Gamma_1(N)\)</span>, note that <span class="math display">\[\left(\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right) \left(\begin{matrix}1&amp;-j\\0&amp;1\end{matrix}\right) = \left(\begin{matrix}a&amp;-aj+b\\c&amp;-cj+d\end{matrix}\right).\]</span> Therefore if <span class="math inline">\(p\nmid a\)</span> we can make the right-hand side to belong to <span class="math inline">\(\Gamma^0(p)\)</span> for some <span class="math inline">\(j\)</span>. This means that if <span class="math inline">\(p\)</span> divides <span class="math inline">\(N\)</span> then <span class="math inline">\(p\)</span> will not divide <span class="math inline">\(a\)</span> (because of the determinant condition), and thus the set <span class="math inline">\(\{\gamma_j\}\)</span> is a complete set of representatives. If <span class="math inline">\(p\nmid N\)</span>, we need to consider matrices <span class="math inline">\(\left(\begin{smallmatrix}a&amp;b\\c&amp;d\end{smallmatrix}\right)\)</span> with <span class="math inline">\(p\mid a\)</span>. Choose some <span class="math inline">\(\gamma_\infty=\left(\begin{smallmatrix}mp&amp;n\\N&amp;1\end{smallmatrix}\right)\in\Gamma_1(N)\)</span>. Then: <span class="math display">\[\left(\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right) \gamma_\infty^{-1} = \left(\begin{matrix}*&amp;-na+bmp\\0&amp;*\end{matrix}\right).\]</span> Since <span class="math inline">\(p\)</span> divides <span class="math inline">\(-na+bmp\)</span>, the matrix <span class="math inline">\(\left(\begin{smallmatrix}a&amp;b\\c&amp;d\end{smallmatrix}\right)\)</span> is in the coset of <span class="math inline">\(\gamma_\infty\)</span> modulo <span class="math inline">\(\Gamma^0(p)\)</span>. Hence <span class="math inline">\(\{\gamma_j\}\cup \{\gamma_\infty\}\)</span> forms a complete set of representatives. In order to get the orbit representatives for the double coset, we just need to multiply the <span class="math inline">\(\gamma_j\)</span> by the fixed element <span class="math inline">\(\alpha = \left(\begin{smallmatrix}1&amp;0\\0&amp;p\end{smallmatrix}\right)\)</span>.</p>
</div>
</section>
<section id="the-diamond-langle-d-rangle-operators" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="the-diamond-langle-d-rangle-operators"><span class="header-section-number">4.2.2</span> The diamond <span class="math inline">\(\langle d \rangle\)</span> operators</h3>
<p>We define another (finite) set of operators on <span class="math inline">\(M_k(\Gamma_1(N))\)</span>, called the diamond operators. First we need some preliminaries on characters.</p>
<div id="def-" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4.2</strong></span> A modulo <span class="math inline">\(N\)</span> is a group homomorphism <span class="math display">\[\chi\colon ({\mathbb{Z}}/N{\mathbb{Z}})^\times\longrightarrow{\mathbb{C}}^\times.\]</span></p>
</div>
<p>It can be extended to a map <span class="math inline">\(\chi\colon {\mathbb{Z}}\longrightarrow{\mathbb{C}}\)</span> by the recipe <span class="math display">\[\chi(d) = \begin{cases}
\chi(d\bmod N)&amp;(d,N)=1\\
0&amp;(d,N)\neq 1.
\end{cases}\]</span> The resulting function is totally multiplicative: it satisfies <span class="math display">\[\chi(d_1d_2)=\chi(d_1)\chi(d_2)\quad \forall d_1,d_2\in{\mathbb{Z}}.\]</span> Consider the map <span class="math inline">\(\Gamma_0(N)\longrightarrow{\mathbb{Z}}/N{\mathbb{Z}}^\times\)</span> sending a matrix <span class="math inline">\(\left(\begin{smallmatrix}a&amp;b\\c&amp;d\end{smallmatrix}\right)\)</span> to <span class="math inline">\(d\bmod N\)</span>. Its kernel is precisely <span class="math inline">\(\Gamma_1(N)\)</span>, and therefore we obtain an isomorphism <span class="math display">\[\Gamma_0(N)/\Gamma_1(N)\cong ({\mathbb{Z}}/NZ)^\times,\quad \left(\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right) \Gamma_1(N)\mapsto d\bmod N.\]</span></p>
<div id="def-" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4.3</strong></span> Given <span class="math inline">\(d\in {\mathbb{Z}}\)</span> coprime to <span class="math inline">\(N\)</span>, the <span class="math inline">\(\langle d\rangle\)</span> is the operator on <span class="math inline">\(M_k(\Gamma_1(N))\)</span> defined as <span class="math display">\[\langle d \rangle f = f|_k \left(\begin{matrix}a&amp;b\\c&amp;d'\end{matrix}\right),\]</span> where <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>, <span class="math inline">\(d'\)</span> are chosen so that <span class="math inline">\(\left(\begin{smallmatrix}a&amp;b\\c&amp;d'\end{smallmatrix}\right)\)</span> belongs to <span class="math inline">\(\Gamma_0(N)\)</span> and <span class="math inline">\(d'\equiv d\pmod N\)</span>.</p>
</div>
<p>Note that the above is well defined, and only depends on the class of <span class="math inline">\(d\)</span> modulo <span class="math inline">\(N\)</span>. This is precisely because <span class="math inline">\(\Gamma_0(N)/\Gamma_1(N)\cong ({\mathbb{Z}}/NZ)^\times\)</span>. The operator <span class="math inline">\(\langle d\rangle\)</span> is a linear invertible map, and thus it makes sense to look at its eigenspaces.</p>
<div id="def-" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4.4</strong></span> The <em>space of modular forms with character</em> <span class="math inline">\(\chi\)</span> is <span class="math display">\[M_k(\Gamma_0(N),\chi)=\{f\in M_k(\Gamma_1(N))~|~ f|_k\left(\begin{smallmatrix}a&amp;b\\c&amp;d\end{smallmatrix}\right) = \chi(d) f,\left(\begin{smallmatrix}a&amp;b\\c&amp;d\end{smallmatrix}\right)\in \Gamma_0(N)\}.\]</span> The <span class="math inline">\(\chi\)</span> is defined similarly and written <span class="math inline">\(S_k(\Gamma_0(N),\chi)\)</span>.</p>
</div>
<p>Note that <span class="math inline">\(M_k(\Gamma_0(N),\chi)\)</span> can also be defined as <span class="math display">\[M_k(\Gamma_0(N),\chi)=\{f\in M_k(\Gamma_1(N))~|~ \langle d\rangle f = \chi(d) f,\quad d\in ({\mathbb{Z}}/N{\mathbb{Z}})^\times\}.\]</span></p>
<div id="thm-" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4.1</strong></span> There is a decomposition of <span class="math inline">\({\mathbb{C}}\)</span>-vector spaces <span class="math display">\[M_k(\Gamma_1(N))=\bigoplus_{\chi\bmod N} M_k(\Gamma_0(N),\chi),\]</span> where the sum runs over the <span class="math inline">\(\phi(N)=\#({\mathbb{Z}}/N{\mathbb{Z}})^\times\)</span> Dirichlet characters modulo <span class="math inline">\(N\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Picking a basis of <span class="math inline">\(M_k(\Gamma_1(N))\)</span>, we get a representation <span class="math display">\[\rho\colon ({\mathbb{Z}}/N{\mathbb{Z}})^\times\longrightarrow\operatorname{GL}_n({\mathbb{C}}),\quad \rho(d)=\langle d\rangle,\]</span> where <span class="math inline">\(n\)</span> is the dimension of <span class="math inline">\(M_k(\Gamma_1(N))\)</span>. Since <span class="math inline">\(({\mathbb{Z}}/N{\mathbb{Z}})^\times\)</span> is abelian, the representation <span class="math inline">\(\rho\)</span> decomposes as a sum of irreducible representations, which are necessarily one-dimensional. This means that we can pick a basis for <span class="math inline">\(M_k(\Gamma_1(N))\)</span> such that <span class="math display">\[\rho(d) = \operatorname{diag}(\chi_1(d),\ldots,\chi_n(d)).\]</span> This means that <span class="math inline">\(\langle d\rangle\)</span> acts as <span class="math inline">\(\chi_i(d)\)</span> on the <span class="math inline">\(i\)</span>th component. One just needs to collect then the repeated <span class="math inline">\(\chi\)</span> to form <span class="math inline">\(M_k(\Gamma_0(N),\chi)\)</span>.</p>
</div>
</section>
<section id="hecke-operators-on-q-expansions" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="hecke-operators-on-q-expansions"><span class="header-section-number">4.2.3</span> Hecke operators on <span class="math inline">\(q\)</span>-expansions</h3>
<p>In order to study the action of Hecke operators on <span class="math inline">\(q\)</span>-expansion, we introduce two simple operators: if <span class="math inline">\(f=\sum a_n q^n\)</span>, define: <span class="math display">\[U_p f = \sum a_{np} q^n=\sum a_n q^{n/p}.\]</span> The second equality is an abuse of notation: we define <span class="math inline">\(q^{n/p}=0\)</span> if <span class="math inline">\(p\nmid n\)</span>. We define also: <span class="math display">\[V_p f = f(pz) = \sum a_n q^{np} = \sum a_{n/p} q^n.\]</span></p>
<div id="lem-" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 4.4</strong></span> If <span class="math inline">\(f=\sum a_n q^n\)</span>, then</p>
<ol type="1">
<li><p><span class="math display">\[U_p f = \frac 1p \sum_{j=0}^{p-1} f\left(\frac{z+j}{p}\right) = \sum_{j=0}^{p-1} f|_k \left(\begin{matrix}1&amp;j\\0&amp;p\end{matrix}\right).\]</span></p></li>
<li><p><span class="math display">\[V_p f= p^{1-k} f|_k\left(\begin{matrix}p&amp;0\\0&amp;1\end{matrix}\right).\]</span></p></li>
</ol>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Note that if <span class="math inline">\(\zeta_p=e^{\frac{2\pi i}{p}}\)</span> is a primitive <span class="math inline">\(p\)</span>th root of unity, then <span class="math display">\[\sum_{j=0}^{p-1} \zeta_p^{nj} = \begin{cases}
p&amp;p\mid n\\
0&amp;p\nmid n.
\end{cases}\]</span> Now compute: <span class="math display">\[\sum_{j=0}^{p-1} f|_k \left(\begin{matrix}1&amp;j\\0&amp;p\end{matrix}\right) = p^{k-1} p^{-k}\sum_j f\left(\frac{z+j}{p}\right).\]</span> Since <span class="math inline">\(f\)</span> is <span class="math inline">\(1\)</span>-periodic, this is the same as: <span class="math display">\[\frac 1p \sum_j \sum_n a_n e^{2\pi i \frac{z+j}{p}} = \sum_n a_n e^{\frac{2\pi i n z}{p}} \frac 1p \sum_j \zeta_p^{nj}.\]</span> This proves the first statement. The second statement is clear.</p>
</div>
<p>Putting together what we have seen so far, we get a description of <span class="math inline">\(T_p\)</span> in terms of <span class="math inline">\(U_p\)</span>, <span class="math inline">\(V_p\)</span> and the diamond operators.</p>
<div id="thm-" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4.2</strong></span> We have: <span class="math display">\[T_p f = \begin{cases}
U_p f&amp;p\mid N,\\
U_p f + p^{k-1} V_p\langle p\rangle f&amp;p\nmid N.
\end{cases}\]</span></p>
</div>
<div id="cor-" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 4.2</strong></span> If <span class="math inline">\(f\in M_k(\Gamma_0(N),\chi)\)</span> then for all <span class="math inline">\(p\)</span> we have: <span class="math display">\[T_p f= U_p f +\chi(p)p^{k-1}V_p f.\]</span> In particular, if <span class="math inline">\(f\in M_k(\Gamma_0(N))\)</span> then: <span class="math display">\[T_p f =
\begin{cases}
  U_p f&amp;p\mid N,\\
U_p f +p^{k-1}V_pf&amp; p\nmid N.
\end{cases}\]</span></p>
</div>
<p>Moreover, the relation between <span class="math inline">\(U_p\)</span> and <span class="math inline">\(T_P\)</span> allows us to think of <span class="math inline">\(U_p\)</span> as an operator on modular forms, which possibly raises the level.</p>
<div id="cor-" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 4.3</strong></span> &nbsp;</p>
<ol type="1">
<li><p>If <span class="math inline">\(p\mid N\)</span> then <span class="math inline">\(U_p\)</span> maps <span class="math inline">\(M_k(\Gamma_1(N))\)</span> to itself.</p></li>
<li><p>If <span class="math inline">\(p\nmid N\)</span> then <span class="math inline">\(U_p\)</span> maps <span class="math inline">\(M_k(\Gamma_1(N))\)</span> to <span class="math inline">\(M_k(\Gamma_1(Np))\)</span>.</p></li>
</ol>
</div>
<div id="exm-" class="theorem example">
<p><span class="theorem-title"><strong>Example 4.1</strong></span> Consider the Eisenstein series <span class="math display">\[E_k(z)=1-\frac{2k}{B_k}\sum_{n=1}^\infty \sigma_{k-1}(n)q^n\in M_k(\Gamma_1(1)).\]</span></p>
<div id="prp-Ek-is-eigen" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4.4</strong></span> We have: <span class="math display">\[T_p E_k = \sigma_{k-1}(p) E_k = (1+p^{k-1})E_k.\]</span> That is, <span class="math inline">\(E_k\)</span> is an eigenform for all <span class="math inline">\(T_p\)</span>, with eigenvalue <span class="math inline">\(\sigma_{k-1}(p)\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>In general we have seen that, since <span class="math inline">\(E_k\in M_k(\Gamma_0(1))\)</span>), <span class="math display">\[a_n(T_pf)= a_n(U_p f) + p^{k-1} a_n(V_p f) = a_{np}(f)+p^{k-1} a_{n/p}(f).\]</span> So <span class="math display">\[a_0(T_pE_k) = a_0(E_k) + p^{k-1} a_0(E_k) = \sigma_{k-1}(p) a_0(E_k).\]</span> For <span class="math inline">\(n\geq 1\)</span>, we get <span class="math display">\[a_n(T_pE_k) = \frac{-2k}{B_k}\left(\sigma_{k-1}(np)+p^{k-1}\sigma_{k-1}(n/p)\right),\]</span> where we understand that <span class="math inline">\(\sigma_{k-1}(n/p)=0\)</span> if <span class="math inline">\(p\nmid n\)</span>. We claim that: <span class="math display">\[\sigma_{k-1}(pn) + p^{k-1}\sigma_{k-1}(n/p) = \sigma_{k-1}(p)\sigma_{k-1}(n),\quad \forall n\geq 1.\]</span> When <span class="math inline">\(p\nmid n\)</span>, this is just the multiplicativity of <span class="math inline">\(\sigma_{k-1}\)</span>. If <span class="math inline">\(p\mid n\)</span>, write <span class="math inline">\(n=p^em\)</span> with <span class="math inline">\(p\nmid m\)</span>. Then we need to show that for all <span class="math inline">\(e\geq 1\)</span> <span class="math display">\[\sigma_{k-1}(p^{e+1}m) + p^{k-1}\sigma_{k-1}(p^{e-1}m) = \sigma_{k-1}(p)\sigma_{k-1}(p^em).\]</span> This follows easily by dividing both sides by <span class="math inline">\(\sigma_{k-1}(m)\)</span>, which is a common factor of both sides of the equation again by multiplicativity of <span class="math inline">\(\sigma_{k-1}\)</span>.</p>
</div>
<div id="rmk-">
<p>If <span class="math inline">\(f=1+\sum_{n\geq 1} a_n q^n\)</span> is a modular form for <span class="math inline">\({\operatorname{SL}}_2({\mathbb{Z}})\)</span> of weight <span class="math inline">\(k\)</span> and it is an eigenform for <span class="math inline">\(T_p\)</span>, then the eigenvalue must be <span class="math inline">\(\sigma_{k-1}(p)\)</span>, by the first calculation of the above proof. The real content of the proposition is thus that <span class="math inline">\(E_k\)</span> is actually an eigenform.</p>
</div>
</div>
</section>
</section>
<section id="the-hecke-algebra" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="the-hecke-algebra"><span class="header-section-number">4.3</span> The Hecke algebra</h2>
<div id="def-" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4.5</strong></span> Let <span class="math inline">\(N\geq 1\)</span> and <span class="math inline">\(k\in {\mathbb{Z}}\)</span>. The acting on <span class="math inline">\(M_k(\Gamma_1(N))\)</span> is the <span class="math inline">\({\mathbb{C}}\)</span>-subalgebra of <span class="math inline">\({\operatorname{End}}_{\mathbb{C}}M_k(\Gamma_1(N))\)</span> generated by <span class="math display">\[\Big\langle T_p\colon p\text{ prime};\text{ and } \langle d\rangle \colon d\in ({\mathbb{Z}}/N{\mathbb{Z}})^\times\Big\rangle.\]</span> The Hecke algebra is denoted by <span class="math inline">\({\mathbb{T}}(M_k(\Gamma_1(N)))\)</span>. Similarly we define <span class="math inline">\({\mathbb{T}}(S_k(\Gamma_1(N)))\)</span> as a subalgebra of <span class="math inline">\({\operatorname{End}}_{\mathbb{C}}S_k(\Gamma_1(N))\)</span>.</p>
</div>
<div id="thm-" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4.3</strong></span> For every <span class="math inline">\(N\geq 1\)</span> the Hecke algebra <span class="math inline">\({\mathbb{T}}(M_k(\Gamma_1(N)))\)</span> is commutative.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>We must show that for all primes <span class="math inline">\(p\)</span>, <span class="math inline">\(q\)</span> and all elements <span class="math inline">\(e\)</span> and <span class="math inline">\(d\)</span> of <span class="math inline">\(({\mathbb{Z}}/N{\mathbb{Z}})^\times\)</span> we have:</p>
<ol type="1">
<li><p><span class="math inline">\(\langle d\rangle T_p = T_p \langle d\rangle\)</span>,</p></li>
<li><p><span class="math inline">\(\langle d \rangle \langle e\rangle = \langle e\rangle\langle d\rangle\)</span>, and</p></li>
<li><p><span class="math inline">\(T_p T_q = T_q T_p\)</span>.</p></li>
</ol>
<p>First we show (2) and (3) assuming (1). Note that (1) means that <span class="math inline">\(T_p\)</span> preserves the spaces <span class="math inline">\(M_k(\Gamma_0(N),\chi)\)</span> and so it’s enough to check (2) and (3) for forms <span class="math inline">\(f\in M_k(\Gamma_0(N),\chi)\)</span>. This makes (2) obvious. As for (3), we can use the <span class="math inline">\(q\)</span>-expansions: if <span class="math inline">\(f=\sum a_n q^n\)</span>, then <span class="math display">\[a_n(T_p f)= a_{pn}(f) + \chi(p)p^{k-1} a_{n/p}(f).\]</span> Then: <span class="math display">\[\begin{align*}
a_n(T_pT_qf) &amp;= a_{pn}(T_qf) + \chi(p)p^{k-1}a_{n/p}(T_qf)\\
&amp;=a_{pqn}(f) + \chi(q) q^{k-1} a_{pn/q}(f)+\chi(p)p^{k-1}(a_{nq/p}(f)+\chi(q) q^{k-1} a_{n/(pq)}(f)).
\end{align*}\]</span> This formula is symmetric in <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> so we are done.</p>
<p>Finally, to prove (1) we must write <span class="math inline">\(\langle d\rangle\)</span> as a double coset. Let <span class="math inline">\(\gamma\equiv \left(\begin{smallmatrix}*&amp;*\\0&amp;d\end{smallmatrix}\right)\pmod N\)</span>. Write <span class="math inline">\(\Gamma=\Gamma_1(N)\)</span>. Then, since <span class="math inline">\(\Gamma\)</span> is normal in <span class="math inline">\(\Gamma_0(N)\)</span>, we have <span class="math display">\[\Gamma\gamma\Gamma=\Gamma\gamma,\]</span> and thus <span class="math inline">\(\langle d\rangle f = f|_k \gamma\)</span>. We want to show that <span class="math inline">\(\langle d\rangle^{-1}T_p\langle d\rangle = T_p\)</span>. Write <span class="math inline">\(\Gamma\alpha\Gamma=\bigcup_j \Gamma \beta_j\)</span> for the orbit decomposition of the double coset corresponding to <span class="math inline">\(T_p\)</span>. We thus need to show that <span class="math display">\[\Gamma\alpha\Gamma=\bigcup_j \Gamma(\gamma\beta_j\gamma^{-1}).\]</span> We note that <span class="math display">\[\bigcup_j \Gamma (\gamma\beta_j\gamma^{-1}) = \gamma\left(\bigcup_j \Gamma \beta_j\right)\gamma^{-1} = \gamma(\Gamma\alpha\Gamma)\gamma^{-1} = \Gamma(\gamma\alpha\gamma^{-1})\Gamma,\]</span> and one just checks then that <span class="math display">\[\Gamma\alpha\Gamma = \Gamma(\gamma\alpha\gamma^{-1})\Gamma.\]</span></p>
</div>
<p>Next, we define operators <span class="math inline">\(T_n\)</span> and <span class="math inline">\(\langle n\rangle\)</span> for all <span class="math inline">\(n\geq 1\)</span>. First, define <span class="math inline">\(\langle p\rangle =0\)</span> whenever <span class="math inline">\(p\mid N\)</span>. One can implicitly define <span class="math inline">\(T_n\)</span> by the following formula: <span class="math display">\[\sum_{n=1}^\infty T_n n^{-s} = \prod_p \frac{1}{1-T_pp^{-s} + \langle p\rangle p^{k-1-2s}}.\]</span> This in turn is equivalent to the following conditions:</p>
<ol type="1">
<li><p><span class="math inline">\(T_{nm} = T_n T_m\)</span> if <span class="math inline">\((n,m)=1\)</span>,</p></li>
<li><p><span class="math inline">\(T_1 = \operatorname{id}\)</span>, and</p></li>
<li><p>for all primes <span class="math inline">\(p\)</span> and for all <span class="math inline">\(r\geq 2\)</span>, <span class="math display">\[T_{p^r} = T_p T_{p^{r-1}} - p^{k-1}\langle p\rangle T_{p^{r-2}}.\]</span></p></li>
</ol>
<p>From the definition we can see that each <span class="math inline">\(T_n\)</span> is an explicit polynomial on the <span class="math inline">\(T_p\)</span>, and therefore all <span class="math inline">\(T_n\)</span> commute with each other.</p>
<div id="thm-" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4.4</strong></span> Suppose <span class="math inline">\(f\in M_k(\Gamma_1(N))\)</span> has an expansion of the form <span class="math inline">\(\sum a_m(f)q^m\)</span>. Then <span class="math inline">\(T_n(f)=\sum a_m(T_nf) q^m\)</span>, where <span class="math display">\[a_m(T_nf) = \sum_{d\mid (m,n)} d^{k-1}a_{\frac{mn}{d^2}}(\langle d\rangle f).\]</span> In particular, if <span class="math inline">\(f\in M_k(\Gamma_0(N),\chi)\)</span> then <span class="math display">\[a_m(T_nf)=\sum_{d\mid (m,n)} \chi(d) d^{k-1} a_{\frac{mn}{d^2}}(f).\]</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>A long computation.</p>
</div>
<p>We end this section with the notion of Hecke eigenforms.</p>
<div id="def-" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4.6</strong></span> A (or just eigenform) is a non-zero modular form <span class="math inline">\(f\in M_k(\Gamma_1(N))\)</span> which is an eigenvector for all the Hecke algebra <span class="math inline">\({\mathbb{T}}(M_k(\Gamma_1(N))\)</span>. A (or normalized eigenform) is an eigenform satisfying <span class="math inline">\(a_1(f)=1\)</span>.</p>
</div>
<p>Let <span class="math inline">\(f\in M_k(\Gamma_1(N))\)</span> be an eigenform, say <span class="math inline">\(T_nf=\lambda_n f\)</span> for all <span class="math inline">\(n\)</span>. Then we obtain <span class="math display">\[a_n(f) = a_1(T_n f) = \lambda_n a_1(f),\quad n\geq 1.\]</span> So if <span class="math inline">\(a_1(f)=0\)</span> then all <span class="math inline">\(a_n(f)=0\)</span> and thus <span class="math inline">\(f=0\)</span>. Therefore a non-constant non-zero eigenform must have <span class="math inline">\(a_1(f)\neq 0\)</span> and it may be scaled to a normalized eigenform. In particular, we have the following.</p>
<div id="thm-" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4.5</strong></span> Let <span class="math inline">\(f\in M_k(\Gamma_1(N))\)</span> be a normalized eigenform. Then the eigenvalues of the Hecke operators on <span class="math inline">\(f\)</span> are precisely the coefficients of the <span class="math inline">\(q\)</span>-expansion of <span class="math inline">\(f\)</span> at the cusp <span class="math inline">\(\infty\)</span>: <span id="eq-ans-for-hecke"><span class="math display">\[
T_n f = a_n(f) f,\quad n\geq 1. \tag{4.1}\]</span></span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Write <span class="math inline">\(\lambda_n\)</span> for the eigenvalue of the Hecke operator <span class="math inline">\(T_n\)</span>. By <a href="#eq-ans-for-hecke" class="quarto-xref">Equation&nbsp;<span>4.1</span></a> we have <span class="math inline">\(a_n(f) = a_1(T_n f) = \lambda_n a_1(f)\)</span>. Since <span class="math inline">\(f\)</span> is normalized, <span class="math inline">\(a_1(f)=1\)</span> and hence <span class="math inline">\(a_n(f) = \lambda_n\)</span>.</p>
</div>
<p>In fact, the Fourier coefficients of a modular form readily tell whether it is a normalized eigenform:</p>
<div id="prp-coeffsnormalizedeigen" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4.5</strong></span> Let <span class="math inline">\(f\in M_k(\Gamma_0(N),\chi)\)</span> be a modular form with <span class="math inline">\(q\)</span>-expansion <span class="math inline">\(\sum_{n=0}^\infty a_n(f) q^n\)</span>. Then <span class="math inline">\(f\)</span> is a normalized eigenform if and only if:</p>
<ol type="1">
<li><p><span class="math inline">\(a_1(f) = 1\)</span>,</p></li>
<li><p><span class="math inline">\(a_{mn}(f) = a_m(f) a_n(f)\)</span> whenever <span class="math inline">\((m,n)=1\)</span>, and</p></li>
<li><p><span class="math inline">\(a_{p^r}(f) = a_p(f)a_{p^{r-1}}(f) - p^{k-1}\chi(p) a_{p^{r-2}}(f),\quad r\geq 2\)</span>.</p></li>
</ol>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>The implication <span class="math inline">\(\implies\)</span> follows directly from the previous proposition and the definition of the Hecke operators <span class="math inline">\(T_n\)</span>. For the converse, if <span class="math inline">\(f\in M_k(\Gamma_0(N),\chi)\)</span> satisfies <span class="math inline">\((1)\)</span>, <span class="math inline">\((2)\)</span> and <span class="math inline">\((3)\)</span> then <span class="math inline">\(f\)</span> is already normalized, so to be an eigenform we must show that it satisfies <span class="math display">\[a_m(T_pf)=a_p(f)a_m(f),\quad \forall p\text{ prime}, \forall m\geq 1.\]</span> If <span class="math inline">\(p\nmid n\)</span> then it follows from the formula that we have for <span class="math inline">\(T_m\)</span> on <span class="math inline">\(q\)</span>-expansions that <span class="math inline">\(a_m(T_pf)=a_{pm}(f)\)</span>, which by <span class="math inline">\((2)\)</span> is <span class="math inline">\(a_p(f)a_m(f)\)</span>. If <span class="math inline">\(p\mid m\)</span> then writing <span class="math inline">\(m=p^rm'\)</span> with <span class="math inline">\(r\geq 1\)</span> and <span class="math inline">\(p\nmid m'\)</span> we have by the same formula <span class="math display">\[a_m(T_pf) = a_{p^{r+1}m'}(f) + \chi(p)p^{k-1}a_{p^{r-1}m'}(f).\]</span> Using now conditions <span class="math inline">\((2)\)</span> and <span class="math inline">\((3)\)</span> this can be rewritten as <span class="math inline">\(a_p(f)a_m(f)\)</span>, as wanted.</p>
</div>
</section>
<section id="petersson-inner-product" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="petersson-inner-product"><span class="header-section-number">4.4</span> Petersson inner product</h2>
<section id="surface-integrals" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="surface-integrals"><span class="header-section-number">4.4.1</span> Surface integrals</h3>
<p>Let <span class="math inline">\(V\subseteq {\mathbb{C}}\)</span>. A <span class="math inline">\(2\)</span>-form on <span class="math inline">\(V\)</span> is an expression of the form <span class="math inline">\(\omega = f(z,\bar z)dz\wedge d\bar z\)</span>. Note that <span class="math display">\[dz\wedge d\bar z = (dx + i dy)\wedge (dx-idy) = -2idx\wedge dy.\]</span> The integral of <span class="math inline">\(\omega\)</span> on <span class="math inline">\(V\)</span> is: <span class="math display">\[\int_V \omega = \int_V f(z,\bar z dz\wedge d\bar z=\int\int -2i f(x+iy,x-iy)dxdy.\]</span> Consider now, for <span class="math inline">\(\alpha\in\operatorname{GL}_2^+({\mathbb{R}})\)</span>, the change <span class="math inline">\(z\mapsto \alpha z\)</span>. Then: <span class="math display">\[\Im(\alpha z)=\frac{\det \alpha}{|cz+d|^2}\Im(z),\]</span> and also <span class="math display">\[d(\alpha z) = \frac{\det \alpha}{(cz+d)^2} dz,\quad \overline{d(\alpha z)} = \frac{\det\alpha}{\overline{(cz+d)^2}} d\bar z.\]</span> This gives that: <span class="math display">\[d(\alpha z)\wedge d\overline{\alpha z} = \frac{(\det \alpha)^2}{|cz + d|^4} dz\wedge d\bar z.\]</span> Therefore the <span class="math inline">\(2\)</span>-form <span class="math inline">\(\frac{dz\wedge d\bar z}{\Im(z)^2}\)</span> is invariant under changes of the form <span class="math inline">\(z\mapsto \alpha z\)</span>. We will work instead with a certain multiple of this <span class="math inline">\(2\)</span>-form. Define <span class="math display">\[d\mu(z) = \frac{dx\wedge dy}{y^2} = \frac{-1}{2i} \frac{dz\wedge d\bar z}{\Im(z)^2}.\]</span> We can define the of <span class="math inline">\({\operatorname{SL}}_2({\mathbb{Z}})\)</span> as <span class="math display">\[{\operatorname{covol}}({\operatorname{SL}}_2({\mathbb{Z}})) = \int_{D^*} d\mu(z).\]</span> where <span class="math inline">\(D^*\)</span> is a fundamental domain for <span class="math inline">\({\operatorname{SL}}_2({\mathbb{Z}})\)</span>.</p>
<div id="lem-" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 4.5</strong></span> <span class="math display">\[{\operatorname{covol}}({\operatorname{SL}}_2({\mathbb{Z}})) = \frac{\pi}{3}.\]</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Exercise.</p>
</div>
<div id="cor-" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 4.4</strong></span> If <span class="math inline">\(\varphi\)</span> is a bounded function on <span class="math inline">\(D^*\)</span>, then <span class="math inline">\(\int_{D^*} \varphi(z)d\mu(z)\)</span> is a well-defined complex number.</p>
</div>
</section>
<section id="integral-over-xgamma" class="level3" data-number="4.4.2">
<h3 data-number="4.4.2" class="anchored" data-anchor-id="integral-over-xgamma"><span class="header-section-number">4.4.2</span> Integral over <span class="math inline">\(X(\Gamma)\)</span></h3>
<p>Let <span class="math inline">\(\mathcal{D}\)</span> be a fundamental domain for a congruence subgroup <span class="math inline">\(\Gamma\)</span>. Such a fundamental domain is the union (almost disjoint) of translates of <span class="math inline">\(D^*\)</span>: <span class="math display">\[\mathcal{D}=\cup_j \alpha_j D^*,\]</span> where <span class="math inline">\(\{\alpha_j\}\)</span> is a set of coset representatives for <span class="math inline">\((\pm 1\cdot \Gamma)\backslash {\operatorname{SL}}_2({\mathbb{Z}})\)</span>. If <span class="math inline">\(\varphi\)</span> is <span class="math inline">\(\Gamma\)</span>-invariant, then we may define the integral of <span class="math inline">\(\varphi\)</span> on <span class="math inline">\(X(\Gamma)=\Gamma\backslash {\mathbb{H}}\)</span> as: <span class="math display">\[\int_{X(\Gamma)} \varphi(\tau) d\mu(\tau) = \sum_j \int_{\alpha_j D^*} \varphi(\tau)d\mu(\tau) = \sum_j\int_{D^*} \varphi(\alpha_j\tau)d\mu(\alpha_j\tau)=\sum_j\int_{D^*} \varphi(\alpha_j\tau)d\mu(\tau).\]</span> The last term in the above equality shows that the definition is independent of the choice of coset representatives. We may calculate the covolume of <span class="math inline">\(\Gamma\)</span> as:</p>
<div id="lem-covolume" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 4.6</strong></span> Let <span class="math inline">\(\Gamma\subset{\operatorname{SL}}_2({\mathbb{Z}})\)</span> be a congruence subgroup. Then <span class="math display">\[{\operatorname{covol}}(\Gamma)= \int_{X(\Gamma)} d\mu(\tau) = [\operatorname{PSL}_2({\mathbb{Z}})\colon \overline\Gamma]{\operatorname{covol}}({\operatorname{SL}}_2({\mathbb{Z}})) = \frac{\pi}{3} [\operatorname{PSL}_2({\mathbb{Z}})\colon \overline\Gamma].\]</span></p>
</div>
<p>Let <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> be two cusp forms for <span class="math inline">\(\Gamma\)</span> of weight <span class="math inline">\(k\)</span>, and set <span class="math inline">\(\varphi(\tau)=f(\tau)\overline{g(\tau)}\Im(\tau)^k\)</span>.</p>
<div id="lem-" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 4.7</strong></span> The function <span class="math inline">\(\varphi\)</span> is <span class="math inline">\(\Gamma\)</span>-invariant and, for all <span class="math inline">\(\alpha\in {\operatorname{SL}}_2({\mathbb{Z}})\)</span>, the translate <span class="math inline">\(\varphi(\alpha\tau)\)</span> is bounded on <span class="math inline">\(D^*\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>If <span class="math inline">\(\gamma\)</span> belongs to <span class="math inline">\(\Gamma\)</span>, then we may compute: <span class="math display">\[\varphi(\gamma\tau)=f|_k\gamma j(\gamma,\tau)^{-k}\overline{g|_k\gamma j(\gamma,\tau)^{-k}} j(\gamma,\tau)^{2k}\Im(z)^k = \varphi(\tau).\]</span> If <span class="math inline">\(\alpha\)</span> belongs to <span class="math inline">\({\operatorname{SL}}_2({\mathbb{Z}})\)</span>, then: <span class="math display">\[\varphi(\alpha\tau)=f|_k\alpha \overline{g|_k\alpha}\Im(\tau)^k = O(q_h)\overline{O(q_h)} y^k = O(|q_h|^2 y^k).\]</span> This approaches <span class="math inline">\(0\)</span> as <span class="math inline">\(y\)</span> approaches infinity, because <span class="math inline">\(q_h = e^{\frac{2\pi i (x+iy)}{z}}\)</span>. This gives boundedness.</p>
</div>
<p>The previous lemma allows us to define an inner product on the spaces of cusp forms:</p>
<div id="def-" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4.7</strong></span> The of <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> is: <span class="math display">\[\langle f,g\rangle_\Gamma = \frac{1}{{\operatorname{covol}}(\Gamma)}\int_{X(\Gamma)} f(\tau)\overline{g(\tau)} \Im(\tau)^kd\mu(\tau).\]</span></p>
</div>
<div id="rmk-">
<p>For the above to converge it is enough that one of the forms <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> is in <span class="math inline">\(S_k\)</span>. Therefore the product of a modular form with a cusp form is well defined.</p>
</div>
<div id="rmk-">
<p>The reason to divide by <span class="math inline">\({\operatorname{covol}}(\Gamma)\)</span> is that, in this way, if <span class="math inline">\(\Gamma\subseteq \Gamma'\)</span> then <span class="math display">\[\langle f,g\rangle_\Gamma=\langle f,g\rangle_{\Gamma'}.\]</span></p>
</div>
<div id="prp-" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4.6</strong></span> The Petersson inner product is a positive-definite hermitian product on the <span class="math inline">\({\mathbb{C}}\)</span>-vector space <span class="math inline">\(S_k(\Gamma)\)</span>. That is:</p>
<ol type="1">
<li><p><span class="math inline">\(\langle a_1 f_1 + a_2 f_2,g\rangle_\Gamma = a_1\langle f_1,g\rangle_\Gamma + a_2\langle f_2,g\rangle_\Gamma\)</span>.</p></li>
<li><p><span class="math inline">\(\langle g,f\rangle_\Gamma = \overline{\langle f,g\rangle_\Gamma}\)</span>.</p></li>
<li><p><span class="math inline">\(\langle f,f\rangle\geq 0\)</span>, with equality if and only if <span class="math inline">\(f=0\)</span>.</p></li>
</ol>
</div>
<p>Although the Petersson inner product does not extend to all of <span class="math inline">\(M_k(\Gamma)\)</span>, it still allows us to define an “orthogonal complement to <span class="math inline">\(S_k(\Gamma)\)</span>:</p>
<div id="def-" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4.8</strong></span> The of <span class="math inline">\(M_k(\Gamma)\)</span> is the space <span class="math display">\[{\mathcal{E}}_k(\Gamma) = \{f\in M_k(\Gamma)~|~ \langle f,g\rangle_\Gamma =0 \quad \forall g\in S_k(\Gamma)\}.\]</span></p>
</div>
</section>
<section id="adjoint-operators" class="level3" data-number="4.4.3">
<h3 data-number="4.4.3" class="anchored" data-anchor-id="adjoint-operators"><span class="header-section-number">4.4.3</span> Adjoint operators</h3>
<p>If <span class="math inline">\(\langle\cdot,\cdot\rangle\)</span> is an hermitian product on a <span class="math inline">\({\mathbb{C}}\)</span>-vector space <span class="math inline">\(V\)</span> and <span class="math inline">\(T\colon V\longrightarrow V\)</span> is a linear operator, the of <span class="math inline">\(T\)</span> is defined as the operator <span class="math inline">\(T^*\)</span> which satisfies: <span class="math display">\[\langle Tf,g\rangle = \langle f,T^*g\rangle.\]</span> The goal of this subsection is to calculate the adjoint operators to the Hecke operators. We will need the following technical result.</p>
<div id="lem-" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 4.8</strong></span> Let <span class="math inline">\(\Gamma\subset{\operatorname{SL}}_2({\mathbb{Z}})\)</span> be a congruence subgroup and let <span class="math inline">\(\alpha\in \operatorname{GL}_2^+({\mathbb{Q}})\)</span>.</p>
<ol type="1">
<li><p>If <span class="math inline">\(\varphi\colon{\mathbb{H}}\longrightarrow{\mathbb{C}}\)</span> is continuous, bounded and <span class="math inline">\(\Gamma\)</span>-invariant then: <span class="math display">\[\int_{\alpha^{-1}\Gamma\alpha\backslash{\mathbb{H}}} \varphi(\alpha\tau)d\mu(\tau) = \int_{\Gamma\backslash{\mathbb{H}}} \varphi(\tau)d\mu(\tau).\]</span></p></li>
<li><p>If <span class="math inline">\(\alpha^{-1}\Gamma\alpha\)</span> is contained in <span class="math inline">\({\operatorname{SL}}_2({\mathbb{Z}})\)</span> then <span class="math inline">\(\Gamma\)</span> and <span class="math inline">\(\alpha^{-1}\Gamma\alpha\)</span> have equal covolumes and indices in <span class="math inline">\({\operatorname{SL}}_2({\mathbb{Z}})\)</span>.</p></li>
<li><p>Let <span class="math inline">\(n=[\Gamma\colon\alpha^{-1}\Gamma\alpha\cap\Gamma] = [\Gamma\colon \alpha\Gamma\alpha^{-1}\cap\Gamma]\)</span>. There are matrices <span class="math inline">\(\beta_1,\ldots,\beta_n\in\operatorname{GL}_2^+({\mathbb{Q}})\)</span> inducing disjoint unions <span class="math display">\[\Gamma\alpha\Gamma = \bigcup \Gamma \beta_j = \bigcup \beta_j \Gamma.\]</span></p></li>
</ol>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>The first two statements are easy and follow from the change of variables formula and <a href="#lem-covolume" class="quarto-xref">Lemma&nbsp;<span>4.6</span></a>. The equality of indices in (3) follows by applying (2) to <span class="math inline">\(\alpha\Gamma\alpha^{-1}\cap\Gamma\)</span> instead of <span class="math inline">\(\Gamma\)</span> and using multiplicativity of indices. Therefore there exist <span class="math inline">\(\gamma_1,\ldots\gamma_n\)</span> and <span class="math inline">\(\tilde\gamma_1,\ldots,\tilde\gamma_n\)</span> in <span class="math inline">\(\Gamma\)</span> such that <span class="math display">\[\Gamma = \bigcup (\alpha^{-1}\Gamma\alpha \cap \Gamma)\gamma_j = \bigcup (\alpha\Gamma\alpha^{-1}\cap \Gamma)\tilde\gamma_j^{-1}.\]</span> By how coset representatives are linked to orbit representatives in a double coset, we get: <span class="math display">\[\Gamma\alpha\Gamma = \bigcup \Gamma \alpha\gamma_j,\quad \Gamma\alpha^{-1}\Gamma=\bigcup \Gamma\alpha^{-1}\tilde\gamma_j^{-1}.\]</span> By taking inverses in the second decomposition we get <span class="math display">\[\Gamma\alpha\Gamma = \bigcup \tilde\gamma_j\alpha\Gamma.\]</span> Suppose that <span class="math inline">\(\Gamma\alpha\gamma_j\cap \tilde\gamma_j\alpha\Gamma = \emptyset\)</span>. Then <span class="math display">\[\Gamma\alpha\gamma_j\subset\bigcup_{i\neq j} \tilde\gamma_i\alpha\Gamma.\]</span> Multiply from the right by <span class="math inline">\(\Gamma\)</span> to get <span class="math inline">\(\Gamma\alpha\Gamma\subset \bigcup_{i\neq j} \tilde\gamma_i\alpha\Gamma\)</span>, a contradiction with the decomposition of <span class="math inline">\(\Gamma\alpha\Gamma\)</span> into <span class="math inline">\(n\)</span> orbits for <span class="math inline">\(\Gamma\)</span>. Therefore we deduce that <span class="math inline">\(\Gamma\alpha\gamma_j\)</span> intersects <span class="math inline">\(\tilde\gamma_j\alpha\Gamma\)</span>, for each <span class="math inline">\(j\)</span>. Let <span class="math inline">\(\beta_j\)</span> be any element in this intersection. This gives <span class="math display">\[\Gamma\alpha\Gamma=\bigcup\Gamma\beta_j = \bigcup\beta_j\Gamma.\]</span></p>
</div>
<p>This allows us to compute adjoints of double coset operators.</p>
<div id="prp-adjoints-double-cosets" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4.7</strong></span> Let <span class="math inline">\(\Gamma\subseteq {\operatorname{SL}}_2({\mathbb{Z}})\)</span> be a congruence subgroup and let <span class="math inline">\(\alpha\in\operatorname{GL}_2^+({\mathbb{Q}})\)</span>. Let <span class="math inline">\(\alpha^*=\det(\alpha)\alpha^{-1}\)</span> be the classical adjoint to <span class="math inline">\(\alpha\)</span>. Then</p>
<ol type="1">
<li><p>If <span class="math inline">\(\alpha^{-1}\Gamma\alpha\subseteq {\operatorname{SL}}_2({\mathbb{Z}})\)</span>, and <span class="math inline">\(f\in S_k(\Gamma)\)</span> and <span class="math inline">\(g\in S_k(\alpha^{-1}\Gamma\alpha)\)</span>, <span class="math display">\[\langle f|_k\alpha,g\rangle_{\alpha^{-1}\Gamma\alpha}=\langle f,g|_k\alpha^*\rangle_\Gamma.\]</span></p></li>
<li><p>For all <span class="math inline">\(f,g\in S_k(\Gamma)\)</span>, <span class="math display">\[\langle f|_k[\Gamma\alpha\Gamma],g\rangle = \langle f,g|_k[\Gamma\alpha^*\Gamma]\rangle.\]</span></p></li>
</ol>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>We prove only (1). The second statement follows easily. We will use the equalities that we have already seen: <span class="math display">\[j(\alpha,\alpha^*z) = j(\alpha\alpha^*,z)j(\alpha^*,z)^{-1} = \det \alpha j(\alpha^*,z)^{-1},\quad \Im(\alpha^*z) = \frac{\det\alpha^*}{|j(\alpha^*,z)|^2} \Im(z).\]</span> Let <span class="math inline">\(M={\operatorname{covol}}(\Gamma)={\operatorname{covol}}(\alpha^{-1}\Gamma\alpha)\)</span>. Then we compute: <span class="math display">\[\begin{align*}
M\langle f|_k\alpha,g\rangle_{\alpha^{-1}\Gamma\alpha} &amp;=  \int_{\alpha^{-1}\Gamma\alpha\backslash{\mathbb{H}}} (\det\alpha)^{k-1}j(\alpha,z)^{-k}f(\alpha z) \overline{g(z)} \Im(z)^k d\mu(z)\\
&amp;= \int_{\Gamma\backslash{\mathbb{H}}} (\det\alpha)^{k-1}j(\alpha,\alpha^*z)^{-k} f(z)\overline{g(\alpha^*z)}\Im(\alpha^*z)^kd\mu(z)\\
&amp;=\int_{\Gamma\backslash {\mathbb{H}}} (\det\alpha)^{k-1}(\det\alpha)^{-k}f(z)j(\alpha^*,z)^k\overline{g(\alpha^*z)} \frac{(\det\alpha^*)^k}{|j(\alpha^*,z)|^{2k}}\Im(z)^kd\mu(z)\\
&amp;=\int_{\Gamma\backslash{\mathbb{H}}} f(z)(\det \alpha)^{k-1} \overline{j(\alpha^*,z)}^{-k} \overline{g(\alpha^*z)} \Im(z)^kd\mu(z)\\
&amp;=\int_{\Gamma\backslash{\mathbb{H}}} f(z)\overline{g|_k\alpha^*(z)} \Im(z)^kd\mu(z) = M\langle f,g|_k\alpha^*\rangle_\Gamma.
\end{align*}\]</span></p>
</div>
<div id="def-" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4.9</strong></span> A linear operator <span class="math inline">\(T\)</span> is if it commutes with its adjoint: <span class="math display">\[T T^* = T^* T.\]</span></p>
</div>
<div id="thm-" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4.6</strong></span> Consider the <span class="math inline">\({\mathbb{C}}\)</span>-vector space <span class="math inline">\(S_k(\Gamma_1(N))\)</span>. If <span class="math inline">\(p\nmid N\)</span> then: <span class="math display">\[\langle p\rangle^* = \langle p\rangle^{-1} = \langle p^{-1}\rangle,\text{ and } T_p^* = \langle p\rangle^{-1} T_p.\]</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Write <span class="math inline">\(\langle p\rangle = [\Gamma\alpha\Gamma]\)</span>, where <span class="math inline">\(\alpha\in\Gamma_0(N)\)</span> is such that modulo <span class="math inline">\(N\)</span> is congruent to <span class="math inline">\(\left(\begin{smallmatrix}a&amp;b\\0&amp;p\end{smallmatrix}\right)\)</span>. By <a href="#prp-adjoints-double-cosets" class="quarto-xref">Proposition&nbsp;<span>4.7</span></a>, we have that <span class="math inline">\(\langle p\rangle^*\)</span> consists on acting with <span class="math inline">\(\alpha^*=\det\alpha \alpha^{-1}\)</span>. Since <span class="math inline">\(\det\alpha=1\)</span>, then <span class="math inline">\(\alpha^*=\alpha^{-1}\)</span> and thus <span class="math inline">\(\langle p\rangle^* = \langle p^{-1}\rangle = \langle p\rangle^{-1}\)</span>.</p>
<p>As for the second part, we set <span class="math inline">\(\alpha=\left(\begin{smallmatrix}1&amp;0\\0&amp;p\end{smallmatrix}\right)\)</span> and we need to compute <span class="math inline">\(\Gamma\alpha^*\Gamma\)</span>. Note that <span class="math display">\[\alpha^*=\left(\begin{matrix}p&amp;0\\0&amp;1\end{matrix}\right)=\left(\begin{matrix}1&amp;n\\N&amp;mp\end{matrix}\right) ^{-1} \left(\begin{matrix}1&amp;0\\0&amp;p\end{matrix}\right) \left(\begin{matrix}p&amp;n\\N&amp;m\end{matrix}\right),\quad mp-nN=1.\]</span> In the right-hand side, the first matrix is in <span class="math inline">\(\Gamma_1(N)\)</span> and the last is in <span class="math inline">\(\Gamma_0(N)\)</span>. Since <span class="math inline">\(\Gamma_0(N)\)</span> is normal in <span class="math inline">\(\Gamma_1(N)\)</span>, we get <span class="math display">\[\Gamma_1(N)\left(\begin{matrix}p&amp;0\\0&amp;1\end{matrix}\right)\Gamma_1(N)=\Gamma_1(N)\left(\begin{matrix}1&amp;0\\0&amp;p\end{matrix}\right)\Gamma_1(N)\left(\begin{matrix}p&amp;n\\N&amp;m\end{matrix}\right).\]</span> Since <span class="math inline">\(m\equiv p^{-1}\pmod N\)</span>, the matrix <span class="math inline">\(\left(\begin{matrix}p&amp;n\\N&amp;m\end{matrix}\right)\)</span> acts as <span class="math inline">\(\langle p^{-1}\rangle\)</span>. Therefore: <span class="math display">\[T_p^*f = \sum_j f|_k\beta_j \left(\begin{matrix}p&amp;n\\N&amp;m\end{matrix}\right) = (T_pf)|_k \left(\begin{matrix}p&amp;n\\N&amp;m\end{matrix}\right) = \langle p^{-1}\rangle T_p f.\]</span></p>
</div>
<div id="cor-" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 4.5</strong></span> If <span class="math inline">\(n\)</span> is coprime to <span class="math inline">\(N\)</span>, the Hecke operators <span class="math inline">\(T_n\)</span> and <span class="math inline">\(\langle n\rangle\)</span> are normal.</p>
</div>
<div id="thm-" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4.7</strong></span> Let <span class="math inline">\(T\)</span> be a normal operator on a finite dimensional <span class="math inline">\({\mathbb{C}}\)</span>-vector space. Then <span class="math inline">\(T\)</span> has an orthogonal basis of eigenvectors.</p>
</div>
<p>Applying this theorem multiple times we deduce that if a <span class="math inline">\({\mathbb{C}}\)</span>-vector space has a family of normal, pairwise commuting operators then it has a basis of simultaneous eigenvectors. Particularizing to our situation, we get the following result.</p>
<div id="cor-" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 4.6</strong></span> The space <span class="math inline">\(S_k(\Gamma_1(N))\)</span> has an orthogonal basis of simultaneous eigenforms for all the <span class="math inline">\(T_n\)</span> and <span class="math inline">\(\langle n\rangle\)</span> with <span class="math inline">\((n,N)=1\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Apply the spectral theorem for the first of the <span class="math inline">\(T_n\)</span>, to get an orthogonal basis of eigenforms. To each of the subspaces one can apply the second of the <span class="math inline">\(T_n\)</span> to refine the basis, thanks to the fact that the Hecke operators commute with each other and hence preserve eigenspaces. The process terminates after a finite number of steps because <span class="math inline">\(S_k(\Gamma_1(N))\)</span> is finite-dimensional.</p>
</div>
<p>Consider <span class="math inline">\(S_k({\operatorname{SL}}_2({\mathbb{Z}})) = S_k(\Gamma_1(1))\)</span>. It has a basis of eigenforms for <em>all</em> the Hecke operators <span class="math inline">\(T_n\)</span> (and <span class="math inline">\(\langle n\rangle\)</span>). We may normalize the eigenforms <span class="math inline">\(f\)</span> so that <span class="math inline">\(a_1(f)=1\)</span>. Then we will obtain: <span class="math display">\[T_n f = a_n(f) f,\quad \forall n.\]</span> Therefore each system of eigenvalues <span class="math inline">\(\{a_n(f)\}_{n\geq 1}\)</span> corresponds to a <em>unique</em> eigenform <span class="math inline">\(f\)</span>. We say that <span class="math inline">\(S_k({\operatorname{SL}}_2({\mathbb{Z}}))\)</span> satisfies . In other words, <span class="math inline">\(S_k({\operatorname{SL}}_2({\mathbb{Z}}))\)</span> decomposes into a direct sum of one-dimensional eigenspaces. In the next section we investigate when this fails to be true, and what can be done to remedy it.</p>
</section>
</section>
<section id="atkin-lehner-li-theory" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="atkin-lehner-li-theory"><span class="header-section-number">4.5</span> Atkin-Lehner-Li theory</h2>
<p>Let us consider <span class="math inline">\(S_k(\Gamma_1(N))\)</span> for an arbitrary <span class="math inline">\(N\)</span>. We have already seen that there is a basis of simultaneous eigenforms for the <span class="math inline">\(T_n\)</span> and <span class="math inline">\(\langle n\rangle\)</span> operators, as long as <span class="math inline">\(n\)</span> is coprime to <span class="math inline">\(N\)</span>. We want to investigate if the components of this basis are also eigenforms for the remaining Hecke operators and if multiplicity one is satisfied.</p>
<p>Recall the operator <span class="math inline">\(V_d\colon M_k(\Gamma_1(M))\longrightarrow M_k(\Gamma_1(Md))\)</span> which was introduced before for <span class="math inline">\(d\)</span> a prime: <span class="math display">\[(V_d f)(\tau) = f(d\tau) = d^{1-k} f|_k\left(\begin{matrix}d&amp;0\\0&amp;1\end{matrix}\right).\]</span> If <span class="math inline">\((t,d)=1\)</span> then it is easy to check that <span class="math inline">\(V_d U_t = U_t V_d\)</span>, and hence <span class="math inline">\(V_d T_n = T_n V_d\)</span> whenever <span class="math inline">\((n,d)=1\)</span>.</p>
<section id="examples" class="level3" data-number="4.5.1">
<h3 data-number="4.5.1" class="anchored" data-anchor-id="examples"><span class="header-section-number">4.5.1</span> Examples</h3>
<p>Both <span class="math inline">\(\Delta(z)\)</span> and <span class="math inline">\(\Delta(2z)\)</span> are cusp forms in <span class="math inline">\(S_{12}(\Gamma_1(2))\)</span>. Write <span class="math display">\[\Delta = \sum_{n\geq 1} \tau(n) q^n,\]</span> so that <span class="math inline">\(T_p \Delta=\tau(p)\Delta\)</span> for all <span class="math inline">\(p\)</span>. Here, by <span class="math inline">\(T_2\)</span> we mean the Hecke operator as acting on <span class="math inline">\(S_{12}({\operatorname{SL}}_2({\mathbb{Z}}))\)</span>. By what we have seen above, we have: <span class="math display">\[T_p(\Delta(2z)) = \tau(p)\Delta(2z),\quad p\neq 2.\]</span> Therefore <span class="math inline">\(\Delta(z)\)</span> and <span class="math inline">\(\Delta(2z)\)</span> have, when considered in <span class="math inline">\(S_{12}(\Gamma_1(2))\)</span>, the same “system of eigenvalues” <span class="math inline">\(\{\tau(n)\}_{(n,2)=1}\)</span>. Therefore <span class="math inline">\(S_{12}(\Gamma_1(2))\)</span> does not satisfy multiplicity one.</p>
<p>However, the Hecke operator <span class="math inline">\(T_2=U_2\)</span> as acting on <span class="math inline">\(S_{12}(\Gamma_1(2))\)</span> satisfies: <span class="math display">\[U_2(\Delta(2z)) = \Delta(z),\text{ and } U_2(\Delta(z)) = T_2\Delta - 2^{11}V_2(\Delta) = -24\Delta(z) - 2^{11} \Delta(2z).\]</span> Therefore <span class="math inline">\(U_2\)</span> acts on <span class="math inline">\(S_{12}(\Gamma_1(2))\)</span> with matrix <span class="math display">\[[U_2] = \left(\begin{matrix}-24&amp;1\\-2^{11}&amp;0\end{matrix}\right),\]</span> which is diagonalizable. The eigenvectors <span class="math display">\[f_{\pm} = \Delta(z) +  (12 \pm 4\sqrt{-119})\Delta(2z)\]</span> can be completed to give a basis of eigenforms for all the <span class="math inline">\(T_n\)</span>.</p>
<p>The following example shows that sometimes one may not get a basis of eigenforms for all <span class="math inline">\(T_p\)</span>. Let <span class="math inline">\(f\in S_2(\Gamma_1(N))\)</span> be an eigenform for <span class="math inline">\(\{T_q\}_{q\nmid N}\cup\{U_q\}_{q\mid N}\)</span>, and let <span class="math inline">\(p\nmid N\)</span>. Let <span class="math inline">\(S\)</span> be the following <span class="math inline">\(4\)</span>-dimensional <span class="math inline">\({\mathbb{C}}\)</span>-vector subspace of <span class="math inline">\(S_2(\Gamma_1(Np^3))\)</span>: <span class="math display">\[S = \operatorname{span}_{\mathbb{C}}\{f(\tau),f(p\tau),f(p^2\tau),f(p^3\tau)\}.\]</span> Since <span class="math inline">\(T_q\)</span> commutes with <span class="math inline">\(V_p\)</span>, the subspace <span class="math inline">\(S\)</span> is stable under <span class="math inline">\(\{T_q\}_{q\nmid Np^3}\)</span>. Moreover, <span class="math inline">\(S\)</span> is also stable under <span class="math inline">\(\{T_q=U_q\}_{q\mid N}\)</span>. The following result shows that <span class="math inline">\(S\)</span> does not satisfy multiplicity one.</p>
<div id="prp-" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4.8</strong></span> &nbsp;</p>
<ol type="1">
<li><p><span class="math inline">\(S\)</span> is stable under <span class="math inline">\(\{T_q\}_{q\nmid Np^3} \cup \{T_q=U_q\}_{q \mid N}\cup \{T_p=U_p\}\)</span>.</p></li>
<li><p>The matrix of <span class="math inline">\(U_p\)</span> is not diagonalizable.</p></li>
</ol>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Exercise.</p>
</div>
</section>
<section id="sec:newforms" class="level3" data-number="4.5.2">
<h3 data-number="4.5.2" class="anchored" data-anchor-id="sec:newforms"><span class="header-section-number">4.5.2</span> New and old forms</h3>
<p>Suppose that <span class="math inline">\(M\mid N\)</span> are two positive integers. There are many ways to embed <span class="math inline">\(S_k(\Gamma_1(M))\)</span> into <span class="math inline">\(S_k(\Gamma_1(N))\)</span>. For example, for any <span class="math inline">\(d\)</span> such that <span class="math inline">\(dM\mid N\)</span>, we can map <span class="math inline">\(f\)</span> to <span class="math inline">\(V_df\)</span>.</p>
<div id="def-" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4.10</strong></span> The , denoted by <span class="math inline">\(S_k(\Gamma_1(N))^\text{old}\)</span> is: <span class="math display">\[S_k(\Gamma_1(N))^\text{old} = \operatorname{span}_{\mathbb{C}}\left\{ V_d(S_k(\Gamma_1(M))) ~\colon~ dM\mid N, M\neq N\right\}.\]</span> The , denoted by <span class="math inline">\(S_k(\Gamma_1(N))^\text{new}\)</span> is the orthogonal complement (with respect to the Petersson inner product) of <span class="math inline">\(S_k(\Gamma_1(N))^\text{old}\)</span> in <span class="math inline">\(S_k(\Gamma_1(N))\)</span>.</p>
</div>
<div id="thm-" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4.8</strong></span> The spaces <span class="math inline">\(S_k(\Gamma_1(N))^\text{old}\)</span> and <span class="math inline">\(S_k(\Gamma_1(N))^\text{new}\)</span> are stable under <em>all</em> Hecke operators.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">\(\ell\)</span> be a prime dividing <span class="math inline">\(N\)</span>. We may define <span class="math display">\[S_k(\Gamma_1(N))^{\ell-\text{old}} = \iota S_k(\Gamma_1(N/\ell)) + V_\ell S_k(\Gamma_1(N/\ell)),\]</span> where <span class="math inline">\(\iota\)</span> is embedding induced by <span class="math inline">\(f\mapsto f\)</span>. In this way, <span class="math display">\[S_k(\Gamma_1(N))^\text{old} = \sum_{\ell \mid N} S_k(\Gamma_1(N))^{\ell-\text{old}},\]</span> where the sum runs over prime divisors <span class="math inline">\(\ell\)</span> of <span class="math inline">\(N\)</span>. What we will prove is that each of the spaces <span class="math inline">\(S_k(\Gamma_1(N))^{\ell-\text{old}}\)</span> is stable under the diamond operators, the Hecke operators <span class="math inline">\(T_p\)</span>, and their adjoints. Note also that if <span class="math inline">\(V\subset S_k(\Gamma_1(N))\)</span> is a subspace which stable under an operator <span class="math inline">\(T\)</span>, then the orthogonal complement to <span class="math inline">\(V\)</span> is stable under the adjoint <span class="math inline">\(T^*\)</span>.</p>
<p>Let <span class="math inline">\(f\in S_k(\Gamma_1(N/\ell))\)</span>, and let <span class="math inline">\(T\)</span> be one of the Hecke operators above. We must prove that <span class="math inline">\(T(\iota f)\)</span> and <span class="math inline">\(T(V_\ell f)\)</span> are in <span class="math inline">\(S_k(\Gamma_1(N))^{\ell-\text{old}}\)</span>. Consider the matrix <span class="math inline">\(\left(\begin{smallmatrix}a&amp;b\\c&amp;d\end{smallmatrix}\right) \in \Gamma_0(N)\)</span>, which defines the operator <span class="math inline">\(\langle d\rangle\)</span> on <span class="math inline">\(S_k(\Gamma_1(N))\)</span> and on <span class="math inline">\(S_k(\Gamma_1(N/\ell))\)</span>. This shows that <span class="math inline">\(\langle d\rangle\)</span> preserves <span class="math inline">\(\iota S_k(\Gamma_1(N/\ell))\)</span>. Next, note that that <span class="math display">\[\left(\begin{matrix}\ell &amp;0\\0&amp;1\end{matrix}\right)\left(\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right) = \left(\begin{matrix}a&amp;b\ell\\c/\ell&amp;d\end{matrix}\right) \left(\begin{matrix}\ell &amp;0\\0&amp;1\end{matrix}\right).\]</span> Since <span class="math inline">\(c/\ell\)</span> is an integer which is divisible by <span class="math inline">\(N/\ell\)</span>, the matrix <span class="math inline">\(\left(\begin{smallmatrix}a&amp;b\ell\\c/\ell&amp;d\end{smallmatrix}\right)\)</span> defines the operator <span class="math inline">\(\langle d\rangle\)</span> on <span class="math inline">\(S_k(\Gamma_1(N/\ell))\)</span>. Therefore the matrix equality above gives <span class="math inline">\(\langle d\rangle(V_\ell f) = V_\ell(\langle d\rangle \iota f)\)</span>.</p>
<p>Next we prove that the operators <span class="math inline">\(T_p\)</span> also preserve <span class="math inline">\(S_k(\Gamma_1(N))^{\ell-\text{old}}\)</span>. If <span class="math inline">\(p\)</span> does not divide <span class="math inline">\(N\)</span> this is easy to show that <span class="math inline">\(T_p\)</span> preserves both <span class="math inline">\(V_\ell S_k(\Gamma_1(N/\ell))\)</span> and <span class="math inline">\(\iota S_k(\Gamma_1(N/\ell))\)</span>. When <span class="math inline">\(p\)</span> does divide <span class="math inline">\(N\)</span> but <span class="math inline">\(p\neq \ell\)</span>, the same argument works. We now consider <span class="math inline">\(T_\ell\)</span>. Suppose that <span class="math inline">\(\ell\)</span> divides <span class="math inline">\(N\)</span> exactly once. Then <span class="math display">\[T_\ell(\iota f) = \iota U_\ell f,\text{ and }\quad T_\ell(V_\ell f) = \iota f.\]</span> However, in <span class="math inline">\(S_k(\Gamma_1(N/\ell))\)</span> we have <span class="math display">\[\iota T_\ell f = T_\ell (\iota f ) + \ell^{k-1}V_\ell(\langle \ell\rangle f),\text{ so } T_\ell(\iota f) = \iota T_\ell f - \ell^{k-1} V_\ell(\langle\ell\rangle f).\]</span> In particular we see that <span class="math inline">\(T_\ell(\iota f)\)</span> and <span class="math inline">\(T_\ell(V_\ell f)\)</span> are in <span class="math inline">\(S_k(\Gamma_1(N))^{\ell-\text{old}}\)</span>.</p>
<p>Finally if <span class="math inline">\(\ell^2\)</span> divides <span class="math inline">\(N\)</span> then <span class="math inline">\(T_\ell\)</span> acts as <span class="math inline">\(U_\ell\)</span> in both <span class="math inline">\(S_k(\Gamma_1(N/\ell))\)</span> and <span class="math inline">\(S_k(\Gamma_1(N))\)</span>, and hence <span class="math display">\[T_\ell \iota f = \iota T_\ell f,\quad T_\ell V_d f = \iota f.\]</span></p>
<p>It only remains to show that the adjoint of <span class="math inline">\(T_p\)</span> preserves <span class="math inline">\(S_k(\Gamma_1(N))^{\ell-\text{old}}\)</span> when <span class="math inline">\(p\)</span> divides <span class="math inline">\(N\)</span> (when <span class="math inline">\(p\)</span> does not divide <span class="math inline">\(N\)</span>, the adjoints of Hecke operators are in the Hecke algebra and hence preserves the old subspace. In this case, consider the Fricke operator <span class="math inline">\(w_N\)</span> acting on <span class="math inline">\(S_k(\Gamma_1(N))\)</span> by <span class="math display">\[f\mapsto f|_k W_N,\quad W_N=\left(\begin{matrix}0&amp;-1\\N&amp;0\end{matrix}\right).\]</span> (note that <span class="math inline">\(W_N\)</span> normalizes <span class="math inline">\(\Gamma_1(N)\)</span>). We can check: <span class="math display">\[(w_N f)(z) = z^{-k}f(-1/(Nz)).\]</span> Also, note that <span class="math inline">\(W_N\left(\begin{smallmatrix}1&amp;0\\0&amp;p\end{smallmatrix}\right) W_N^{-1} = \left(\begin{smallmatrix}p&amp;0\\0&amp;1\end{smallmatrix}\right)\)</span>, and thus <span class="math inline">\(T_p^* = w_N^{-1} T_p w_N\)</span>. One can then compute: <span class="math display">\[w_N\iota f = \ell^k V_\ell w_{N/\ell} f,\text{ and } w_N V_\ell f = \iota w_{N/\ell} f.\]</span> Therefore <span class="math inline">\(w_N\)</span> (and hence <span class="math inline">\(T_p^*\)</span>) preserves the old subspace.</p>
</div>
<p>We say that <span class="math inline">\(f\in S_k(\Gamma_1(N))^\text{new}\)</span> is a if it is an <em>eigenform</em> for all Hecke operators, which is <em>normalized</em> so that the leading coefficient is <span class="math inline">\(1\)</span>.</p>
<div id="thm-" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4.9</strong></span> Consider the space <span class="math inline">\(S_k(\Gamma_1(N))^\text{new}\)</span> for <span class="math inline">\(N\geq 1\)</span>.</p>
<ol type="1">
<li><p>The space <span class="math inline">\(S_k(\Gamma_1(N))^\text{new}\)</span> has a basis of newforms.</p></li>
<li><p>If <span class="math inline">\(f\in S_k(\Gamma_1(N))^\text{new}\)</span> is an eigenvector for <span class="math inline">\(\{T_q\}_{q\nmid N}\)</span> then <span class="math inline">\(f\)</span> is a scalar multiple of a newform, and hence an eigenvector for <em>all</em> the Hecke operators.</p></li>
<li><p>If <span class="math inline">\(f\in S_k(\Gamma_1(N))^\text{new}\)</span> and <span class="math inline">\(g\in S_k(\Gamma_1(M))^\text{new}\)</span> are both newforms satisfying <span class="math inline">\(a_q(f)=a_q(g)\)</span> for all but finitely many primes <span class="math inline">\(q\)</span>, then <span class="math inline">\(N=M\)</span> and <span class="math inline">\(f=g\)</span>.</p></li>
</ol>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>This was proven by Atkin–Lehner in 1970 and a partial proof can be found in <span class="citation" data-cites="diamond-shurman">(<a href="bibliography.html#ref-diamond-shurman" role="doc-biblioref">Diamond and Shurman 2005</a>)</span>.</p>
</div>
<div id="cor-atkinlehner" class="theorem corollary">
<p><span class="theorem-title"><strong>Corollary 4.7</strong></span> &nbsp;</p>
<ol type="1">
<li><p>If <span class="math inline">\(f\)</span> is a newform, then there is a Dirichlet character <span class="math inline">\(\chi\)</span> such that <span class="math inline">\(f\in S_k(\Gamma_0(N),\chi)\)</span>.</p></li>
<li><p>If <span class="math inline">\(\{\lambda_n\}_{(n,N)=1}\)</span> is a system of eigenvalues for the <span class="math inline">\(T_n\)</span> such that <span class="math inline">\((n,N)=1\)</span>, then <span class="math inline">\(\exists !\)</span> newform <span class="math inline">\(f\in S_k(\Gamma_1(M))^\text{new}\)</span> for some <span class="math inline">\(M\mid N\)</span>, such that <span class="math inline">\(T_nf = \lambda_n f\)</span> for all <span class="math inline">\(n\)</span> satisfying <span class="math inline">\((n,N)=1\)</span>.</p></li>
</ol>
</div>
<p>Finally, we see that the new subspaces give a complete description of <span class="math inline">\(S_k(\Gamma_1(N))\)</span> and <span class="math inline">\(S_k(\Gamma_0(N))\)</span>.</p>
<div id="thm-" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4.10</strong></span> There are direct sum decompositions <span class="math display">\[S_k(\Gamma_1(N)) = \bigoplus_{M\mid N} \bigoplus_{dM \mid N} V_d\left(S_k(\Gamma_1(M))^\text{new}\right),\]</span> and <span class="math display">\[S_k(\Gamma_0(N)) = \bigoplus_{M\mid N} \bigoplus_{dM \mid N} V_d\left(S_k(\Gamma_0(M))^\text{new}\right).\]</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Write <span class="math inline">\(S_k(\Gamma_1(N))=W_1\oplus\cdots\oplus W_t\)</span>, where each of the <span class="math inline">\(W_i\)</span> is a simultaneous eigenspace for <span class="math inline">\(\{T_n\}_{(n,N)=1}\cup \{\langle n\rangle\}\)</span>. Each form <span class="math inline">\(f\in W_i\)</span> has the same “package” of eigenvalues <span class="math inline">\(\{\lambda_n\}_{(n,N)=1}\)</span>. Therefore by <a href="#cor-atkinlehner" class="quarto-xref">Corollary&nbsp;<span>4.7</span></a> this <span class="math inline">\(f\)</span> comes from a unique newform <span class="math inline">\(f_i\in S_k(\Gamma_1(M_i))^\text{new}\)</span> for some <span class="math inline">\(M_i\mid N\)</span>. Therefore <span class="math display">\[W_i=\bigoplus_{dM_i\mid N} {\mathbb{C}}V_d(f_i)\]</span> as wanted. Since each of these spaces is stable under the diamond operators, we get the second decomposition by further taking the subspaces on which they act trivially.</p>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-diamond-shurman" class="csl-entry" role="listitem">
Diamond, Fred, and Jerry Michael Shurman. 2005. <em>A First Course in Modular Forms</em>. Vol. 228. Springer.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./3_complextori.html" class="pagination-link" aria-label="Moduli interpretation">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Moduli interpretation</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./5_eisenstein.html" class="pagination-link" aria-label="Eisenstein series">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Eisenstein series</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://www.github.com/mmasdeu/modforms/edit/main/4_hecke.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://www.github.com/mmasdeu/modforms/issues" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://www.github.com/mmasdeu/modforms/blob/main/4_hecke.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></div></div></footer></body></html>